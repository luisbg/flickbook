#!/usr/bin/python
#
#  Copyright Luis de Bethencourt Guimera, Andrew Hunter 2008
#
#    This program is free software; you may redistribute it and/or modify it
#    under the terms of the GNU General Public License as published by the Free 
#    Software Foundation; either version 2 of the License, or (at your option) 
#    any later version.
#
#    This program is distributed in the hope that it will be useful, but WITHOUT
#    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or 
#    FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for 
#    more details.
#
#    You should have received a copy of the GNU General Public License
#    along with this program.  If not, see <http://www.gnu.org/licenses/>.

import os
import sys, optparse
import clutter
import gtk
import gobject
import random
import time
import flickroll.core
import flickroll.modes

class FlickBook:
    def __init__(self):

	usage = """ flickbook -f -m [number]
	  While running:'
          Esc key or q   : quit flickbook'
          up key         : speed up image switching.'
	  down key       : slow down image switching.'"""
	
	parser = optparse.OptionParser(usage=usage)
	parser.add_option("-f", "--fullscreen", action="store_true", dest="fullscreen", help="Fullscreen mode", default=False)
	parser.add_option("-m", "--mode", action="store", type="int", dest="mode", help="Animation mode", default=1)
	(options, args) = parser.parse_args()

	self.fullscreen = options.fullscreen
	self.mode = options.mode
      
        self.stage = clutter.stage_get_default()
        if self.fullscreen:
            self.stage.fullscreen()
            self.photosize = 'large'
        else:
            self.stage.set_size(600,600)
            self.photosize = 'medium'
        self.width = self.stage.get_size()[0]
        self.height = self.stage.get_size()[1]
        self.stage.set_color(clutter.color_parse("#000000"))
        self.stage.set_title('Flickbook')
        
        self.stage.connect('key-press-event', self.key_press)

        pixbuf = gtk.gdk.pixbuf_new_from_file_at_size('../files/flickbook.jpg', 600, 600)
        self.image = clutter.texture_new_from_pixbuf(pixbuf)
        self.image.set_position(0,0)
        self.image.set_opacity(0)

        self.label = clutter.Label()
        self.label.set_font_name('You Are Loved 30')

        self.c = 0
        self.i = 0
        self.loop_amount = 42
        self.fps = 50
        self.x_pos = 0
        self.y_pos = 0
        self.beat_count = 0
        self.flickroll = flickroll.core.FlickRoll()

        self.timeline = clutter.Timeline(200,self.fps)
        self.timeline.connect("completed", self.timeline_completed)

        if self.mode == 1:
            self.behave = flickroll.modes.Slideshow(self.timeline, self.fps, self.image)
        elif self.mode == 2:
            self.behave = flickroll.modes.Rotate(self.timeline, self.fps, self.image)
        elif self.mode == 3:
            self.behave = flickroll.modes.Scroll(self.timeline, self.fps, self.image, self.x_pos)
        elif self.mode == 0:
            self.behave = flickroll.modes.Slideshow(self.timeline, self.fps, self.image)
	else:
            self.mode = 1

        self.stage.add(self.image)
        self.stage.add(self.label)
        self.stage.show_all()
        self.timeline.start()

    def next(self, widget):
        file = '%d.jpg' % self.c
        if os.path.exists(file):
            self.image_change(file)
            if self.c < self.loop_amount:
                self.c += 1
            else:
                self.c = 0
	
    def image_change(self, file):
        pixbuf = gtk.gdk.pixbuf_new_from_file_at_size(file, self.width, self.height)
        self.image.set_pixbuf(pixbuf)
        self.image.set_opacity(0x00)
        width = self.image.get_size()[0]
        height = self.image.get_size()[1]
        ratioW = width / float(self.width)
        ratioH = height / float(self.height)
        if ratioW > ratioH:
            ratio = ratioW
        else:
            ratio = ratioH
        width = width * ratio
        self.x_pos = int((self.width / 2) - (width / 2))
        height = height * ratio
        self.y_pos = int((self.height / 2) - (height / 2))
        self.image.set_position(self.x_pos, self.y_pos)

    def new_thread(self, widget):
        self.flickroll.get_first_photo()

    def flickroll_loop(self):
        filename = '%d.jpg' % self.i
        self.flickroll.get_next_photo(filename, self.photosize)
        if self.i < self.loop_amount:
            self.i += 1
        else:
            self.i = 0

    def key_press(self, widget, event):
        key = gtk.gdk.keyval_name(event.keyval)
        if key =='space':
            self.beat_count += 1
            if self.beat_count == 1:
                self.time = time.time()
            elif self.beat_count == 4:
                self.beat_count = 0
                self.time = time.time() - self.time
                self.fps = int(200 / self.time)
                self.timeline.set_speed(self.fps)
                self.behave.set_speed(self.fps)
                key = str(self.mode)
        if key == 'Up':
            self.fps += 1
            self.timeline.set_speed(self.fps)
            self.behave.set_speed(self.fps)
        elif key == 'Down':
            self.fps -= 1
            self.timeline.set_speed(self.fps)
            self.behave.set_speed(self.fps)
        elif key == 'q' or key == 'Escape':
            clutter.main_quit()
        elif key == '1':
            self.behave.disconnect(self.timeline)
            self.behave = flickroll.modes.Slideshow(self.timeline, self.fps, \
                                       self.image)
            self.timeline.rewind()
            self.timeline.start()
            self.mode = 1
        elif key == '2':
            self.behave.disconnect(self.timeline)
            self.behave = flickroll.modes.Rotate(self.timeline, self.fps, \
                                       self.image)
            self.timeline.rewind()
            self.timeline.start()
            self.mode = 2
        elif key == '3':
            self.behave.disconnect(self.timeline)
            self.behave = flickroll.modes.Scroll(self.timeline, self.fps, \
                                       self.image, self.x_pos)
            self.timeline.rewind()
            self.timeline.start()
            self.mode = 3
        elif key == '4':
            self.behave.disconnect(self.timeline)
            self.behave = flickroll.modes.SlideText(self.timeline, self.fps, \
                                       self.image, self.label)
            self.timeline.rewind()
            self.timeline.start()
            self.mode = 4
        elif key == '0':
            self.mode = 0
            self.timeline_completed(self.timeline)

    def timeline_completed(self, data):
        self.timeline.rewind()
        self.timeline.start()
        self.next(self.image)
        self.flickroll_loop()
        if self.mode == 0:
             self.behave.disconnect(self.timeline)
             random_number = random.randint(1, 3)
             if random_number == 1:
                 self.behave = flickroll.modes.Slideshow(self.timeline, self.fps, \
                                               self.image)
             elif random_number == 2:
                 self.behave = flickroll.modes.Rotate(self.timeline, self.fps, \
                                               self.image)
             elif random_number == 3:
                 self.behave = flickroll.modes.Scroll(self.timeline, self.fps, \
                                               self.image, self.x_pos)
	
if __name__ == "__main__":
    flickbook = FlickBook()
    gtk.gdk.threads_init()
    clutter.main()
