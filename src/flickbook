#!/usr/bin/python
#
#  Copyright Luis de Bethencourt Guimera, Andrew Hunter 2008
#
#    This program is free software; you may redistribute it and/or modify it
#    under the terms of the GNU General Public License as published by the Free 
#    Software Foundation; either version 2 of the License, or (at your option) 
#    any later version.
#
#    This program is distributed in the hope that it will be useful, but WITHOUT
#    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or 
#    FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for 
#    more details.
#
#    You should have received a copy of the GNU General Public License
#    along with this program.  If not, see <http://www.gnu.org/licenses/>.

import os
import sys, getopt
import clutter
import gtk
import gobject
import flickroll
import modes

class FlickBook:
    def __init__(self):
        try:
            opts, args = getopt.getopt(sys.argv[1:], "ho:fm", ["help", "fullscreen"])
        except getopt.GetoptError, err:
            # print help information and exit:
            print str(err) # will print something like "option -a not recognized"
            sys.exit(2)

        fullscreen = False
        self.mode = 1
        for o, a in opts:
            if o == "-f":
               fullscreen = True
            if o == "-m":
                self.mode = int(args[0])
            else:
                self.mode = 1
            if o in ("-h", "--help"):
               self.usage()
               sys.exit()

        self.stage = clutter.stage_get_default()
        if fullscreen:
            self.stage.fullscreen()
            self.photosize = 'large'
        else:
            self.stage.set_size(600,600)
            self.photosize = 'medium'
        self.width = self.stage.get_size()[0]
        self.height = self.stage.get_size()[1]
        self.stage.set_color(clutter.color_parse("#000000"))
        self.stage.set_title('Flickbook')
        
        self.stage.connect('key-press-event', self.key_press)

        pixbuf = gtk.gdk.pixbuf_new_from_file_at_size('../files/flickbook.jpg', 600, 600)
        self.image = clutter.texture_new_from_pixbuf(pixbuf)
        self.image.set_position(0,0)
        self.image.set_opacity(0x55)

        self.c = 0
        self.i = 0
        self.loop_amount = 42
        self.fps = 50
        self.flickroll = flickroll.FlickRoll()

        self.timeline = clutter.Timeline(200,self.fps)
        self.timeline.set_loop(True)
        self.timeline.connect("completed", self.timeline_completed)

        if self.mode == 1:
            self.behave = modes.Slideshow(self.timeline, self.image)
        elif self.mode == 2:
            self.behave = modes.Rotate(self.timeline, self.image)

        self.stage.add(self.image)
        self.stage.show_all()
        self.timeline.start()

    def next(self, widget):
        file = '%d.jpg' % self.c
        if os.path.exists(file):
            self.image_change(file)
            if self.c < self.loop_amount:
                self.c += 1
            else:
                self.c = 0

    def image_change(self, file):
        pixbuf = gtk.gdk.pixbuf_new_from_file_at_size(file, self.width, self.height)
        self.image.set_opacity(0x00)
        self.image.set_pixbuf(pixbuf)
        width = self.image.get_size()[0]
        height = self.image.get_size()[1]
        ratioW = width / float(self.width)
        ratioH = height / float(self.height)
        if ratioW > ratioH:
            ratio = ratioW
        else:
            ratio = ratioH
        width = width * ratio
        x_pos = (self.width / 2) - (width / 2)
        height = height * ratio
        y_pos = (self.height / 2) - (height / 2)
        self.image.set_position(int(x_pos), int(y_pos))

    def new_thread(self, widget):
        self.flickroll.get_first_photo()

    def flickroll_loop(self):
        filename = '%d.jpg' % self.i
        self.flickroll.get_next_photo(filename, self.photosize)
        if self.i < self.loop_amount:
            self.i += 1
        else:
            self.i = 0

    def key_press(self, widget, event):
        key = gtk.gdk.keyval_name(event.keyval)
        if key == 'Up':
            self.fps += 1
            self.timeline.set_speed(self.fps)
        if key == 'Down':
            self.fps -= 1
            self.timeline.set_speed(self.fps)
        if key == 'q' or key == 'Escape':
            clutter.main_quit()
        if key == '1':
            self.behave = modes.Slideshow(self.timeline, self.image)
        if key == '2':
            self.behave = modes.Rotate(self.timeline, self.image)

    def timeline_completed(self, data):
        self.timeline.rewind()
        self.timeline.start()
        self.flickroll_loop()
        self.next(self.image)

    def usage(self):
        print '    -f             : For fullscreen mode.'
        print '    -m [ number ]  : For animation mode.'
        print '    -h or --help   : For this help.'
        print ' While running:'
        print '    Esc key or q   : quit flickbook'
        print '    up key         : speed up image switching.'
        print '    down key       : slow down image switching.' 

if __name__ == "__main__":
    flickbook = FlickBook()
    gtk.gdk.threads_init()
    clutter.main()
